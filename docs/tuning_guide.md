Tuning guide for the structure from motion pipeline
===================================================

Many of the tools in the structure from motion pipeline require tuning
to improve the quality of the output and/or the performance. For many
tools, the best configuration to use may also depend on the image
resolution or number of images that are used. In this document we 
describe what setting we have tried so far.

SIFT
----

Sift generates the keypoints for each image. Each keypoint describes a
_distinctive feature_ in the image in a scale an rotation independent 
way. By matching the keypoints in each image with all other images, the
SfM pipeline can determine which images overlap (partly). 

More information of sift can be found 
[here](http://en.wikipedia.org/wiki/Scale-invariant_feature_transform).

The version of sift we use can be found in the ``bundler_sfm/src/Sift.cpp`` 
file. In this sift implementation, the following settings are important:

- ``SIFT::DoubleImSize`` this setting determines if the the image 
  should be doubled in size before the sift algorithm is run. Sift internally
  downscales the image repeatedly to detect features of different sizes. It 
  always downscales once before detecting the first features. Therefore, very 
  small features cannot be detected unless the image is doubled in size first.
  It is typically good to set this to ``true`` for low resolution images 
  (e.g. 1024x768) and ``false`` for high resolution images (as produced by 
  modern cameras). In our pipeline the default is ``false``.
  
- ``SIFT::PeakThreshInit`` this setting determines the minimum contrast required 
  for a point to be considered as a keypoint. Dark areas in images typically result 
  in _noisy_ keypoints which are easily confused with others. In our pipeline the
  default is ``0.08``. Using lower values will include more keypoints from darker 
  areas.
  
KeyPoint matching
-----------------

After sift, the keypoints generated for the images are compared using a keypoint matcher. 
The matchers we use, ``KeyMatchFull`` or ``KeyMatchPart`` are part of the bundler tool set. 
These matchers compare the keypoints using a _approximate nearest neighbor KD tree_. More
information on the implementation of these trees can be found [here](https://www.cs.umd.edu/~mount/ANN/)

The matcher we of use can be found in the ``bundler_sfm/src/KeyMatchPart.cpp`` 
file. In this matcher implementation, the following settings are important:

- ``ratio`` is the fifth (optional) parameter to KeyMatchPart. During matching, each keypoint in one image is compared to all keypoints in another image by computing the euclidean distance between the feature vectors of the two keypoints. The ratio of the distance of the two best matches (the best and the runner up) are then computed. If this ratio is close to 1, the match is considered to be bad, since there are multiple 'potential' matches for the keypoint. If the ratio is closer to 0, the match is considered good, since the difference (and thus the distance) between the best match and the runner up is large. The ratio parameter determines the threshold above which matches are discarded. The default in our pipeline is `0.6`. Higher values will make the matching less strict and thus produce more matches of lower quality. 


Bundler
-------

After matching, bundler takes the keypoints and attempts to reconstruct the camera positions in 3D space for each images. In addition, a sparse point cloud is created that contains a relatively small number of object points in 3D space. 

Bundler reads it configuration from a text file `options.txt` which is generated by the `run-sfm.py` script we us in our pipeline. In this configuration file, the following settings are important:

- ``--use_ceres`` is used to switch between the ceres solver and the internal solver of bundler. Using ceres significantly improves the performance of bundler, as it is capable of using all cores in a machine. 

- ``--construct_max_connectivity`` is used to instruct bundler to add images in the order of how _connected_ they are to other images. That is, images containing features than can be matched to many other images are added first. The alternative is to add images based on the number of matches, which tends to add images based on how similar the are to the current set. 

- ``--projection_estimation_threshold 1.1`` is the RANSAC threshold used when doing pose estimation to add in a new image. Lower values will result in a stricter selection of which estimates are valid. The default value used in bundler is 4, which seemed to result in too noisy estimates of the camera positions. A lower value resulted higher quality result. 

CMVS/PMVS2
----------

After estimating the camera positions, PMVS2 is used to estimate the 3D positions of object points. Before 
PMVS2 is run, CMVS is used to read the output of bundler and create a configuration file for PMVS2 in `pmvs/option-0000`. In this configuration file specifies which images should be used for the reconstruction, and at what resolution the input images should be used. In this configuration file, the following settings are important:

- ``timages`` the images actually used in the reconstruction of the 3D object. Usually only a subset of the input images is used. 

- ``level`` this setting determines how much the input images are down sampled before 3D reconstruction. Level 0 means full resolution, 1 uses half the resolution, etc. We use 0 for the best result. Reducing this to 1 will significantly reduce the computation time and the number of points in the result.

- ``threshold`` this setting determines which patch reconstructions are accepted. Lower values will accept more patches but will produce a in noisier result. Higher values will accept less patches and will produce a result with less errors, but more missing points. We use the default of `0.7`.

- ``maxAngle`` determines the minimal angle between cameras before they are considered for 3D reconstruction. If the baseline between the cameras is too small, the 3D reconstruction tend to have higher errors. We use the default angle of 10 degrees.  

- ``CPU`` determined the number of cores used by PMVS2. Our `run-sfm.py` script detects the number of 
cores automatically and generated the correct configuration.


 





